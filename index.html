<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cleared Page</title>
  <title>Neon Tunnel WebGL</title>
  <style>
    :root { color-scheme: light; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f7f8fa;
      color: #1a1d21;
    }
    .message {
      text-align: center;
      max-width: 600px;
      padding: 2rem;
      border: 1px solid #d9dde3;
      border-radius: 12px;
      background: #ffffff;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
    }
    h1 { margin: 0 0 0.5rem; font-size: 1.5rem; }
    p { margin: 0; color: #4a4f57; line-height: 1.5; }
    body { margin: 0; overflow: hidden; background-color: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div class="message">
    <h1>Page cleared</h1>
    <p>The previous visuals have been removed. You can add your own content here.</p>
  </div>
  <canvas id="glcanvas"></canvas>
  <script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
      alert('Unable to initialize WebGL. Your browser or machine may not support it.');
    }

    const vsSource = `
      attribute vec4 aVertexPosition;
      void main() {
        gl_Position = aVertexPosition;
      }
    `;

    const fsSource = `
      precision mediump float;
      uniform float uTime;
      uniform vec2 uResolution;

      void main() {
        // Normalize coordinates to center
        vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution.xy) / uResolution.y;
        
        float r = length(uv);
        float a = atan(uv.y, uv.x);
        
        // Tunnel depth mapping
        float z = 1.0 / r;
        
        // Animation
        float t = uTime * 0.5;
        
        // Grid pattern generation
        // z * 10.0 creates rings, a * 8.0 creates radial lines
        float grid = sin(z * 10.0 - t * 10.0) * sin(a * 8.0 + sin(t * 0.5) * 2.0);
        
        // Neon glow effect (inverse distance to grid lines)
        float glow = 0.02 / abs(grid);
        
        // Neon Colors: Cyan and Magenta/Pink
        vec3 col1 = vec3(0.1, 0.9, 1.0); 
        vec3 col2 = vec3(1.0, 0.1, 0.8); 
        
        // Mix colors based on depth and time
        vec3 color = mix(col1, col2, sin(z * 0.5 + t) * 0.5 + 0.5);
        
        // Apply glow and fade to black in the center (fog)
        vec3 finalColor = color * glow * r;
        
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      return shaderProgram;
    }

    function loadShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
    const programInfo = {
      program: shaderProgram,
      attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition') },
      uniformLocations: {
        time: gl.getUniformLocation(shaderProgram, 'uTime'),
        resolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
      },
    };

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0]), gl.STATIC_DRAW);

    function render(now) {
      now *= 0.001;
      if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      gl.useProgram(programInfo.program);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
      gl.uniform1f(programInfo.uniformLocations.time, now);
      gl.uniform2f(programInfo.uniformLocations.resolution, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
