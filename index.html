<!-- 
Artifacts Showcase - Version 0.0.38
Improved Console with Smooth Scrolling Log
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Artifacts Showcase</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; 
      height: 100%; 
      overflow: hidden; 
      background: #000; 
      font-family: 'Segoe UI', Arial, sans-serif; 
      touch-action: manipulation;
    }
    
    #milkyway { 
      position: fixed; 
      top: 0; left: 0; 
      width: 100vw; 
      height: 100vh; 
      z-index: 0; 
    }
    
    .overlay { 
      position: relative; 
      z-index: 10; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      width: 100%; 
      height: 100%; 
      color: #fff; 
      text-align: center; 
      opacity: 0; 
      transition: opacity 2s ease; 
    }
    .title { 
      font-size: 3rem; 
      margin-bottom: 2rem; 
      color: #FFA500; 
      text-shadow: 0 0 10px rgba(255,165,0,0.9), 0 0 30px rgba(255,165,0,0.5); 
      letter-spacing: 3px; 
      opacity: 0; 
      animation: fadeIn 3s ease-in-out forwards; 
    }
    .projects { 
      display: flex; 
      gap: 3rem; 
      opacity: 0; 
      animation: fadeIn 3s ease-in-out 1.5s forwards; 
    }
    .project-card { 
      cursor: pointer; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .project-card:hover, .project-card.touch-active { 
      transform: scale(1.1); 
      transition: transform 0.2s ease-out; 
    }
    
    .project-icon { 
      width: 150px; 
      height: 150px; 
      margin-bottom: 1rem; 
      border-radius: 12px; 
      overflow: hidden; 
      background: transparent;
      box-shadow: none;
      transition: transform 0.2s ease-out;
      opacity: 0;
      animation: fadeIn 2s ease-in-out forwards;
    }
    
    #icon-1 { animation-delay: 2s; }
    #icon-2 { animation-delay: 2.3s; }
    #icon-3 { animation-delay: 2.6s; }
    
    .project-card:hover .project-icon, .project-card.touch-active .project-icon { 
      transform: scale(1.1); 
      transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55); 
    }
    
    .project-card span { 
      font-weight: bold; 
      color: #fff; 
      text-shadow: 0 0 5px rgba(255,255,255,0.7); 
      font-size: 1.1rem; 
      transition: all 0.2s ease;
      opacity: 0;
      animation: fadeIn 2s ease-in-out 1s forwards;
    }
    
    .project-card:hover span, .project-card.touch-active span {
      text-shadow: 0 0 15px rgba(255,255,255,0.9);
      transform: translateY(-2px);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Improved Debug Console - Scroll Log Behavior */
    #debug-console {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: calc(100% - 20px);
      max-height: 120px; /* Height for 4 lines */
      background: rgba(0,20,0,0.9);
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 5px;
      z-index: 100;
      overflow: hidden;
      border-radius: 3px;
      box-shadow: 0 0 10px rgba(0,255,0,0.3);
    }
    
    .console-message {
      opacity: 1;
      margin: 2px 0;
      line-height: 1.2;
      transition: opacity 3s ease-out;
    }
    
    /* Mobile Responsive Styling */
    @media (max-width: 768px) {
      .projects { 
        gap: 1.5rem; 
        flex-wrap: nowrap;
      }
      .project-icon { 
        width: 120px; 
        height: 120px; 
        margin-bottom: 0.6rem;
      }
      .title { 
        font-size: 2rem; 
        margin-bottom: 1.2rem;
      }
      .project-card span { 
        font-size: 0.9rem; 
      }
      #debug-console { 
        font-size: 9px;
        max-height: 90px; /* Height for 4 lines on mobile */
      }
    }
  </style>
</head>
<body>
  <div id="milkyway"></div>
  <div id="debug-console"></div>
  
  <div class="overlay">
    <h1 class="title">ARTIFACTS</h1>
    <div class="projects">
      <div class="project-card" onclick="showArtifact(1)" id="card-1">
        <div class="project-icon" id="icon-1"></div>
        <span>Cosmic Runner</span>
      </div>
      <div class="project-card" onclick="showArtifact(2)" id="card-2">
        <div class="project-icon" id="icon-2"></div>
        <span>Quantum Maze</span>
      </div>
      <div class="project-card" onclick="showArtifact(3)" id="card-3">
        <div class="project-icon" id="icon-3"></div>
        <span>Neural Drift</span>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let scene, camera, renderer;
    let projectScenes = {};
    let projectRenderers = {};
    let projectMeshes = {};
    let time = 0;
    let hoverEffects = {};
    let debugConsole = document.getElementById('debug-console');
    
    // Improved console logging function - scrolling log behavior
    function logMessage(message) {
      console.log(`[COSMIC] ${message}`);
      
      if (debugConsole) {
        const timestamp = new Date().toLocaleTimeString();
        const messageElement = document.createElement('div');
        messageElement.className = 'console-message';
        messageElement.innerHTML = `[${timestamp}] ${message}`;
        
        // Add to top (newest first)
        debugConsole.insertBefore(messageElement, debugConsole.firstChild);
        
        // Get all messages
        const messages = debugConsole.querySelectorAll('.console-message');
        
        // If more than 4 messages, start fading the oldest (topmost)
        if (messages.length > 4) {
          const oldestMessage = messages[messages.length - 1];
          if (!oldestMessage.classList.contains('fading')) {
            // Start fading after a brief delay
            setTimeout(() => {
              if (oldestMessage.parentNode) {
                oldestMessage.classList.add('fading');
                
                // Remove completely after fade completes
                setTimeout(() => {
                  if (oldestMessage.parentNode) {
                    oldestMessage.parentNode.removeChild(oldestMessage);
                  }
                }, 3000); // 3 seconds fade duration
              }
            }, 100); // Small delay to ensure proper ordering
          }
        }
      }
    }
    
    // Show artifact function
    function showArtifact(id) {
      logMessage(`Artifact ${id} selected`);
      alert(`Accessing Artifact ${id}: Placeholder for link...`);
    }
    
    // Force landscape and fullscreen on mobile
    function forceMobileOptimization() {
      // Force fullscreen
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(e => {});
      }
      
      // Lock orientation if possible
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(e => {});
      }
    }
    
    // Create canvas with exact 848x420 resolution
    function createCanvas() {
      const container = document.getElementById('milkyway');
      if (!container) return null;
      
      // Create canvas with exact dimensions
      const canvas = document.createElement('canvas');
      canvas.width = 848;
      canvas.height = 420;
      container.appendChild(canvas);
      
      return canvas;
    }
    
    // Create simple nebula background
    function createSimpleNebula() {
      logMessage("Creating simple nebula background...");
      
      try {
        const container = document.getElementById('milkyway');
        if (!container) {
          logMessage("ERROR: Container not found!");
          return false;
        }
        
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, 848/420, 0.1, 3000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(848, 420);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        logMessage("Three.js renderer initialized (848x420)");
        
        // Create nebula points
        const positions = [];
        const colors = [];
        const sizes = [];
        
        // Generate nebula points
        for (let i = 0; i < 3000; i++) {
          // Position within canvas bounds
          const posX = (Math.random() - 0.5) * 800;
          const posY = (Math.random() - 0.5) * 400;
          const posZ = (Math.random() - 0.5) * 200;
          positions.push(posX, posY, posZ);
          
          // Color (Hubble-like colors)
          const colorType = Math.random();
          if (colorType < 0.4) {
            // Red
            colors.push(1.0, 0.3, 0.3);
          } else if (colorType < 0.7) {
            // Blue
            colors.push(0.3, 0.6, 1.0);
          } else {
            // Green
            colors.push(0.3, 1.0, 0.6);
          }
          
          // Size
          sizes.push(2 + Math.random() * 2);
        }
        
        // Create geometry and material
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        
        const material = new THREE.PointsMaterial({
          size: 2,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending
        });
        
        const nebula = new THREE.Points(geometry, material);
        scene.add(nebula);
        logMessage("Nebula points created (3000 points)");
        
        // Add background stars
        createStars();
        
        camera.position.z = 300;
        
        // Handle resize to maintain aspect ratio
        window.addEventListener('resize', () => {
          // Maintain 848x420 aspect ratio
          const windowRatio = window.innerWidth / window.innerHeight;
          const canvasRatio = 848 / 420;
          
          if (windowRatio > canvasRatio) {
            // Window is wider, fit height
            renderer.setSize(window.innerHeight * canvasRatio, window.innerHeight);
          } else {
            // Window is taller, fit width
            renderer.setSize(window.innerWidth, window.innerWidth / canvasRatio);
          }
          
          camera.aspect = 848 / 420;
          camera.updateProjectionMatrix();
          logMessage("Canvas resized to maintain aspect ratio");
        });
        
        logMessage("Simple nebula initialization complete");
        return true;
      } catch (error) {
        logMessage(`ERROR creating nebula: ${error.message}`);
        return false;
      }
    }
    
    // Create background stars
    function createStars() {
      logMessage("Creating background starfield...");
      
      const positions = [];
      const colors = [];
      const sizes = [];
      
      for (let i = 0; i < 5000; i++) {
        // Position within canvas bounds
        const radius = Math.sqrt(Math.random()) * 1000;
        const angle = Math.random() * Math.PI * 2;
        const height = (Math.random() - 0.5) * 500;
        positions.push(radius * Math.cos(angle), height, radius * Math.sin(angle));
        
        // Color (star colors)
        const colorType = Math.random();
        if (colorType < 0.7) {
          colors.push(1.0, 1.0, 1.0); // White
        } else if (colorType < 0.85) {
          colors.push(0.8, 0.9, 1.0); // Blue-white
        } else {
          colors.push(1.0, 0.9, 0.7); // Yellow-orange
        }
        
        // Size
        sizes.push(0.5 + Math.random() * 1.0);
      }
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
      
      const material = new THREE.PointsMaterial({
        size: 1.0,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
      });
      
      const stars = new THREE.Points(geometry, material);
      scene.add(stars);
      logMessage("Background starfield created (5000 stars)");
    }
    
    // Create Project Icons
    function createProjectIcons() {
      logMessage("Creating project icons...");
      createProjectIcon('icon-1', 'icosahedron', 0xff6600); // Orange
      createProjectIcon('icon-2', 'torus', 0x0096D6);      // Blue
      createProjectIcon('icon-3', 'dodecahedron', 0x9932cc); // Purple
      logMessage("Project icons creation initiated");
    }
    
    // Create Individual Project Icon
    function createProjectIcon(containerId, geometryType, color) {
      try {
        logMessage(`Creating ${geometryType} icon (${containerId})...`);
        const container = document.getElementById(containerId);
        if (!container) {
          logMessage(`ERROR: Container ${containerId} not found!`);
          return;
        }
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(120, 120); // Smaller for mobile
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        logMessage(`${containerId} renderer attached`);
        
        // Geometry
        let geometry;
        switch(geometryType) {
          case 'icosahedron':
            geometry = new THREE.IcosahedronGeometry(2.2, 0);
            break;
          case 'torus':
            geometry = new THREE.TorusGeometry(2.0, 0.6, 8, 16);
            break;
          case 'dodecahedron':
            geometry = new THREE.DodecahedronGeometry(2.2, 0);
            break;
          default:
            geometry = new THREE.BoxGeometry(2.2, 2.2, 2.2);
        }
        
        const material = new THREE.MeshPhongMaterial({
          color: color,
          specular: 0xffffff,
          shininess: 85,
          flatShading: geometryType === 'torus',
          transparent: true,
          opacity: 0.95,
          emissive: new THREE.Color(color),
          emissiveIntensity: 0.15
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
        logMessage(`${geometryType} geometry created`);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2.2);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.3);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        camera.position.z = 6;
        
        // Store references
        projectScenes[containerId] = scene;
        projectRenderers[containerId] = renderer;
        projectMeshes[containerId] = mesh;
        
        // Add hover effect tracking
        hoverEffects[containerId] = { 
          isHovered: false,
          swooshStartTime: 0,
          swooshActive: false,
          startRotation: { x: 0, y: 0, z: 0 },
          targetRotation: { x: 0, y: 0, z: 0 },
          randomTwist: { x: 0, y: 0, z: 0 }
        };
        
        logMessage(`${containerId} icon ready`);
      } catch (error) {
        logMessage(`ERROR creating ${containerId}: ${error.message}`);
      }
    }
    
    // Start 5-second rotation
    function startRotation(containerId) {
      const effect = hoverEffects[containerId];
      if (!effect) return;
      
      effect.swooshStartTime = Date.now();
      effect.swooshActive = true;
      
      const mesh = projectMeshes[containerId];
      if (mesh) {
        effect.startRotation = {
          x: mesh.rotation.x,
          y: mesh.rotation.y,
          z: mesh.rotation.z
        };
      }
      
      // Generate random twists for 5-second animation
      effect.randomTwist = {
        x: (Math.random() - 0.5) * Math.PI * 4,
        y: (Math.random() - 0.5) * Math.PI * 6,
        z: (Math.random() - 0.5) * Math.PI * 3
      };
      
      effect.targetRotation = {
        x: effect.startRotation.x + Math.PI * 2 + effect.randomTwist.x,
        y: effect.startRotation.y + Math.PI * 3 + effect.randomTwist.y,
        z: effect.startRotation.z + Math.PI * 1.5 + effect.randomTwist.z
      };
      
      logMessage(`Started 5-second rotation for ${containerId}`);
    }
    
    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      
      // Animate nebula scene
      if (scene) {
        scene.rotation.y += 0.0001;
      }
      
      // Camera gentle movement
      if (camera) {
        camera.position.x = Math.sin(time * 0.03) * 30;
        camera.position.y = Math.cos(time * 0.02) * 20;
        camera.lookAt(0, 0, 0);
      }
      
      // Render background
      if (renderer && scene && camera) {
        renderer.render(scene, camera);
      }
      
      // Animate project icons
      Object.keys(projectMeshes).forEach(key => {
        const mesh = projectMeshes[key];
        const effect = hoverEffects[key];
        
        if (mesh && effect) {
          // Base gentle rotation when not rotating
          if (!effect.swooshActive) {
            mesh.rotation.x += 0.002;
            mesh.rotation.y += 0.003;
            mesh.rotation.z += 0.001;
          }
          
          // Handle 5-second rotation
          if (effect.swooshActive) {
            const elapsed = (Date.now() - effect.swooshStartTime) / 1000;
            const progress = Math.min(elapsed / 5, 1);
            
            // Smooth easing
            const easedProgress = progress < 0.5 
              ? 4 * progress * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 3) / 2;
            
            // Calculate current rotation
            mesh.rotation.x = effect.startRotation.x + (effect.targetRotation.x - effect.startRotation.x) * easedProgress;
            mesh.rotation.y = effect.startRotation.y + (effect.targetRotation.y - effect.startRotation.y) * easedProgress;
            mesh.rotation.z = effect.startRotation.z + (effect.targetRotation.z - effect.startRotation.z) * easedProgress;
            
            // End rotation after 5 seconds
            if (progress >= 1) {
              effect.swooshActive = false;
              logMessage(`5-second rotation complete for ${key}`);
              
              // If still hovered, start another rotation
              if (effect.isHovered) {
                startRotation(key);
              }
            }
          }
        }
        
        const renderer = projectRenderers[key];
        const scene = projectScenes[key];
        const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
        camera.position.z = 6;
        
        if (renderer && scene) {
          renderer.render(scene, camera);
        }
      });
    }
    
    // Initialize everything
    window.addEventListener('load', () => {
      logMessage("=== ARTIFACTS SHOWCASE v0.0.38 BOOT SEQUENCE ===");
      logMessage("System initialization started...");
      
      // Force mobile optimization
      forceMobileOptimization();
      
      // Check if Three.js is available
      if (typeof THREE === 'undefined') {
        logMessage("FATAL: Three.js not loaded!");
        return;
      }
      
      logMessage("Three.js loaded successfully");
      
      try {
        // Create nebula
        const success = createSimpleNebula();
        if (success) {
          logMessage("Nebula background ready");
          
          // Create project icons after a delay
          setTimeout(() => {
            logMessage("Starting project icons creation...");
            createProjectIcons();
            logMessage("Project interface ready");
          }, 800);
          
          // Show interface
          setTimeout(() => {
            logMessage("Showing main interface...");
            document.querySelector('.overlay').style.opacity = '1';
            logMessage("Main interface visible");
          }, 1000);
          
          // Start animation
          logMessage("Animation engine starting...");
          animate();
          logMessage("=== BOOT COMPLETE ===");
        } else {
          logMessage("FATAL: Failed to create nebula background");
        }
      } catch (error) {
        logMessage(`FATAL BOOT ERROR: ${error.message}`);
      }
    });
    
    // Setup hover/touch events
    window.addEventListener('load', () => {
      setTimeout(() => {
        logMessage("Setting up event listeners...");
        Object.keys(projectScenes).forEach(key => {
          const card = document.getElementById(key.replace('icon', 'card'));
          if (card) {
            // Mouse events for desktop
            card.addEventListener('mouseenter', () => {
              if (hoverEffects[key]) {
                hoverEffects[key].isHovered = true;
                startRotation(key);
                logMessage(`Hover enter: ${key}`);
              }
            });
            
            card.addEventListener('mouseleave', () => {
              if (hoverEffects[key]) {
                hoverEffects[key].isHovered = false;
                logMessage(`Hover leave: ${key}`);
              }
            });
            
            // Touch events for mobile
            card.addEventListener('touchstart', (e) => {
              e.preventDefault();
              if (hoverEffects[key]) {
                hoverEffects[key].isHovered = true;
                startRotation(key);
                logMessage(`Touch start: ${key}`);
              }
            });
            
            card.addEventListener('touchend', (e) => {
              e.preventDefault();
              setTimeout(() => {
                if (hoverEffects[key]) {
                  hoverEffects[key].isHovered = false;
                  logMessage(`Touch end: ${key}`);
                }
              }, 150);
            });
          }
        });
        logMessage("Event system active");
      }, 2000);
    });
  </script>
  
  <!-- Load Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</body>
</html>


    
              <script>
                              
              </script>
                        </body>
                        </html>
                    