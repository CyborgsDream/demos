<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Searchlights in the Mist</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Space Grotesk', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(85, 146, 255, 0.2), transparent 32%),
                  radial-gradient(circle at 80% 10%, rgba(255, 125, 255, 0.22), transparent 30%),
                  #050712;
      color: #eef3ff;
      overflow: hidden;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #fractal { z-index: 0; filter: saturate(1.2); }
    #lights { z-index: 1; mix-blend-mode: screen; filter: blur(0.5px); }
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 2;
      text-align: center;
      padding: 3rem 1.5rem;
      pointer-events: none;
      background: radial-gradient(circle at 50% 40%, rgba(0, 0, 0, 0.08), transparent 55%);
    }
    h1 {
      margin: 0 0 0.75rem;
      font-size: clamp(2.5rem, 6vw, 4.75rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      text-shadow: 0 0 35px rgba(255, 255, 255, 0.35),
                   0 0 60px rgba(126, 189, 255, 0.5),
                   0 0 110px rgba(255, 153, 255, 0.4);
    }
    p {
      margin: 0;
      max-width: 720px;
      color: rgba(238, 243, 255, 0.78);
      line-height: 1.6;
      font-weight: 400;
      text-shadow: 0 0 14px rgba(0, 0, 0, 0.35);
    }
    .glow-line {
      width: clamp(120px, 20vw, 220px);
      height: 2px;
      margin: 1.25rem auto 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.55), transparent);
      filter: blur(0.4px);
    }
  </style>
</head>
<body>
  <canvas id="fractal"></canvas>
  <canvas id="lights"></canvas>
  <div class="overlay">
    <div>
      <h1>Veil of Light</h1>
      <p>Beams slice through drifting fog while a living fractal sea ripples behind them. Let your eyes chase the glows as they sweep toward you.</p>
      <div class="glow-line"></div>
    </div>
  </div>
  <script>
    const fractalCanvas = document.getElementById('fractal');
    const lightCanvas = document.getElementById('lights');
    const fractalCtx = fractalCanvas.getContext('2d');
    const lightCtx = lightCanvas.getContext('2d');

    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const state = { width: 0, height: 0 };

    const resize = () => {
      state.width = window.innerWidth;
      state.height = window.innerHeight;
      fractalCanvas.width = state.width * dpr;
      fractalCanvas.height = state.height * dpr;
      fractalCanvas.style.width = `${state.width}px`;
      fractalCanvas.style.height = `${state.height}px`;
      lightCanvas.width = state.width * dpr;
      lightCanvas.height = state.height * dpr;
      lightCanvas.style.width = `${state.width}px`;
      lightCanvas.style.height = `${state.height}px`;
      fractalCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      lightCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    window.addEventListener('resize', resize);
    resize();

    // Fractal plasma settings
    const plasma = {
      scale: 0.65,
      time: 0,
      palette: [
        [12, 15, 42],
        [42, 96, 165],
        [96, 179, 255],
        [195, 136, 255],
        [255, 198, 255]
      ]
    };

    const lerp = (a, b, t) => a + (b - a) * t;
    const samplePalette = (t) => {
      const total = plasma.palette.length;
      const scaled = t * (total - 1);
      const i = Math.floor(scaled);
      const frac = scaled - i;
      const c1 = plasma.palette[i % total];
      const c2 = plasma.palette[(i + 1) % total];
      return [
        Math.round(lerp(c1[0], c2[0], frac)),
        Math.round(lerp(c1[1], c2[1], frac)),
        Math.round(lerp(c1[2], c2[2], frac))
      ];
    };

    const offscreen = document.createElement('canvas');
    const offCtx = offscreen.getContext('2d');

    const drawPlasma = (t) => {
      const w = Math.max(180, Math.floor(state.width * plasma.scale));
      const h = Math.max(120, Math.floor(state.height * plasma.scale));
      offscreen.width = w;
      offscreen.height = h;
      const img = offCtx.createImageData(w, h);
      const data = img.data;
      const speed = t * 0.00025;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const nx = x / w;
          const ny = y / h;
          const wave = Math.sin((nx + ny) * 9 + speed * 2) + Math.sin(nx * 14 - speed * 3);
          const swirl = Math.sin(Math.hypot(nx - 0.5, ny - 0.5) * 20 - speed * 4);
          const v = (wave + swirl * 1.4) * 0.25 + 0.5;
          const [r, g, b] = samplePalette(Math.min(Math.max(v, 0), 1));
          const idx = (y * w + x) * 4;
          data[idx] = r;
          data[idx + 1] = g;
          data[idx + 2] = b;
          data[idx + 3] = 255;
        }
      }

      offCtx.putImageData(img, 0, 0);
      fractalCtx.clearRect(0, 0, state.width, state.height);
      fractalCtx.filter = 'blur(1px) contrast(105%)';
      fractalCtx.drawImage(offscreen, 0, 0, w, h, 0, 0, state.width, state.height);
      fractalCtx.filter = 'none';
    };

    // Light beams in fog
    const beams = Array.from({ length: 4 }).map((_, i) => ({
      angle: Math.random() * Math.PI * 2,
      radius: Math.random() * 180 + 160 + i * 40,
      spread: Math.random() * 220 + 320,
      speed: 0.0035 + Math.random() * 0.002,
      hue: 180 + Math.random() * 120
    }));

    const fogNoise = document.createElement('canvas');
    const fogCtx = fogNoise.getContext('2d');

    const updateFog = () => {
      const fw = Math.max(160, Math.floor(state.width * 0.35));
      const fh = Math.max(120, Math.floor(state.height * 0.35));
      fogNoise.width = fw;
      fogNoise.height = fh;
      const img = fogCtx.createImageData(fw, fh);
      for (let i = 0; i < img.data.length; i += 4) {
        const n = Math.random() * 35;
        img.data[i] = img.data[i + 1] = img.data[i + 2] = n + 15;
        img.data[i + 3] = 18;
      }
      fogCtx.putImageData(img, 0, 0);
    };

    updateFog();

    const drawLights = (t) => {
      lightCtx.fillStyle = 'rgba(2, 4, 10, 0.12)';
      lightCtx.fillRect(0, 0, state.width, state.height);
      const cx = state.width / 2;
      const cy = state.height / 2 + 40;
      lightCtx.globalCompositeOperation = 'screen';

      beams.forEach((beam, idx) => {
        beam.angle += beam.speed;
        const wobble = Math.sin(t * 0.001 + idx) * 0.6;
        const x = cx + Math.cos(beam.angle + wobble) * beam.radius;
        const y = cy + Math.sin(beam.angle - wobble * 0.5) * (beam.radius * 0.45);
        const grad = lightCtx.createRadialGradient(x, y, 0, x, y, beam.spread);
        grad.addColorStop(0, `hsla(${beam.hue}, 80%, 80%, 0.6)`);
        grad.addColorStop(0.35, `hsla(${beam.hue + 20}, 90%, 65%, 0.22)`);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        lightCtx.fillStyle = grad;
        lightCtx.beginPath();
        lightCtx.arc(x, y, beam.spread, 0, Math.PI * 2);
        lightCtx.fill();
      });

      lightCtx.globalCompositeOperation = 'soft-light';
      lightCtx.globalAlpha = 0.75;
      const fogW = fogNoise.width;
      const fogH = fogNoise.height;
      const xOffset = Math.sin(t * 0.0004) * 120;
      const yOffset = Math.cos(t * 0.0003) * 90;
      lightCtx.drawImage(fogNoise, xOffset, yOffset, fogW, fogH, -60, -40, state.width + 120, state.height + 80);
      lightCtx.globalAlpha = 1;
      lightCtx.globalCompositeOperation = 'source-over';
    };

    const loop = (timestamp) => {
      drawPlasma(timestamp);
      drawLights(timestamp);
      requestAnimationFrame(loop);
    };

    requestAnimationFrame(loop);
  </script>
</body>
</html>
